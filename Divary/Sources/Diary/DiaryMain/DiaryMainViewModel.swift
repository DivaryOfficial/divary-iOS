
//
//  DiaryMainViewModel.swift
//  Divary
//

import SwiftUI
import PhotosUI
import ImageIO
import UniformTypeIdentifiers
import RichTextKit
import Observation
import PencilKit
import Combine

@Observable /*@MainActor*/
class DiaryMainViewModel {
    var blocks: [DiaryBlock] = []
    var selectedItems: [PhotosPickerItem] = []
    var editingTextBlock: DiaryBlock? = nil
    var editingImageBlock: DiaryBlock? = nil
    var richTextContext = RichTextContext()
    var forceUIUpdate: Bool = false
    var currentTextAlignment: NSTextAlignment = .left
    
    // ÌòÑÏû¨ Ïª§ÏÑú Ïä§ÌÉÄÏùº ÏÉÅÌÉú
    var currentFontSize: CGFloat = 16.0
    var currentFontName: String = "NanumSquareNeoTTF-cBd"
    var currentIsUnderlined: Bool = false
    var currentIsStrikethrough: Bool = false
    
    // ÎÇ¥Î∂Ä ÏÉÅÌÉú Í¥ÄÎ¶¨
    private var isApplyingStyle: Bool = false
    private var lastCursorPosition: Int = 0
    
    var savedDrawing: PKDrawing? = nil
    var drawingOffsetY: CGFloat = 0
    
    private var injected = false
    private var bag = Set<AnyCancellable>()
    private var diaryService: LogDiaryService?
    private var imageService: ImageService?
    private var token: String?
    
    // Ï†ÄÏû•
    private var currentLogId: Int = 0
    private var hasDiary: Bool = false // ÏÑúÎ≤ÑÏóê ÏùºÍ∏∞ Ï°¥Ïû¨ Ïó¨Î∂Ä(POST/PUT Î∂ÑÍ∏∞)
    
    // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ(ÌååÏùº ÍµêÏ≤¥ Ïïà Ìï®)Îäî tempÍ∞Ä ÎπÑÏñ¥ ÏûàÏñ¥ÎèÑ Ï†ÄÏû• ÌóàÏö©
    var canSave: Bool {
        let imagesReady = blocks.allSatisfy { block in
            if case .image(let f) = block.content {
                let hasTemp = (f.tempFilename?.isEmpty == false)
                let isExistingImage = (f.originalData == nil)   // ÏÑúÎ≤ÑÏóêÏÑú Î∂àÎü¨Ïò® Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ
                return hasTemp || isExistingImage
            }
            return true
        }
        return imagesReady && diaryService != nil && (token?.isEmpty == false)
    }

//    var canSave: Bool {
//        let imagesReady = blocks.allSatisfy { block in
//            if case .image(let f) = block.content {
//                return (f.tempFilename?.isEmpty == false)
//            }
//            return true
//        }
//        return imagesReady && diaryService != nil && (token?.isEmpty == false)
//    }
    
    // Ï†ÄÏû•Î≤ÑÌäº Î∑∞Ïóê ÎÇ¥Î†§Ï£ºÍ∏∞ ÏúÑÌïú ÌååÏÉù Í∞í
    var canSavePublic: Bool = false
    func recomputeCanSave() {
        canSavePublic = canSave
    }

    // MARK: - API Ïó∞Í≤∞
    func inject(diaryService: LogDiaryService, imageService: ImageService, token: String) {
        guard !injected else { return }
        self.diaryService = diaryService
        self.imageService = imageService
        self.token = token
        injected = true
        recomputeCanSave()
    }
    
    // 1) ÏÑúÎ≤ÑÏóêÏÑú ÏùΩÍ∏∞
    func loadFromServer(logId: Int) {
        self.currentLogId = logId
        guard let diaryService, let token else { return }
        diaryService.getDiary(logId: logId, token: token)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] comp in
                if case let .failure(err) = comp {
                    print("‚ùå getDiary error:", err)
                    Task { @MainActor in
                        self?.hasDiary = false // ÏÉùÏÑ± POST ÏúºÎ°ú
                    }
                }
            } receiveValue: { [weak self] dto in
                Task { @MainActor in
                    self?.applyServerDiary(dto)
                    self?.hasDiary = true // ÏàòÏ†ï PUT ÏúºÎ°ú
                }
            }
            .store(in: &bag)
    }

    // 2) ÏùëÎãµ ‚Üí ÌôîÎ©¥ ÏÉÅÌÉú Îß§Ìïë
    @MainActor
    private func applyServerDiary(_ dto: DiaryResponseDTO) {
        var newBlocks: [DiaryBlock] = []

        for c in dto.contents {
            switch c.type {
            case .text:
                if let base64 = c.rtfData,
                   let data = Data(base64Encoded: base64),
                   let rich = RichTextContent(rtfData: data) {
                    newBlocks.append(DiaryBlock(content: .text(rich)))
                } else {
                    newBlocks.append(DiaryBlock(content: .text(RichTextContent())))
                }

            case .image:
                if let img = c.imageData {
                    let frame = mapFrameColor(from: img.frameColor)
                    // ÏõêÍ≤© Ïù¥ÎØ∏ÏßÄÎäî Ïö∞ÏÑ† placeholderÎ°ú ÎßåÎì§Í≥†, ÌïÑÏöîÌïòÎ©¥ ÎπÑÎèôÍ∏∞Î°ú Î°úÎìúÌï¥ÏÑú ÍµêÏ≤¥
                    let item = FramedImageContent(
                        image: Image(systemName: "photo"),
                        caption: img.caption,
                        frameColor: frame,
                        date: img.date
                    )
                    // ÏóÖÎ°úÎìú/ÏÑúÎ≤Ñ Í≤ΩÎ°ú Ï†ÄÏû• (Ïù¥ÌõÑ Ï†ÄÏû• Ïãú tempFilenameÏúºÎ°ú ÏÇ¨Ïö©)
                    item.tempFilename = img.tempFilename
                    newBlocks.append(DiaryBlock(content: .image(item)))
                }
                
                if let s = self.blocks.compactMap({
                    if case let .image(f) = $0.content { return f.tempFilename } else { return nil }
                }).first, let u = URL(string: s) {
                    URLSession.shared.dataTask(with: u) { _, resp, err in
                        print("üîé IMG resp:", (resp as? HTTPURLResponse)?.statusCode ?? -1, "err:", err as Any)
                    }.resume()
                }

            case .drawing:
                if let d = c.drawingData,
                   let bin = Data(base64Encoded: d.base64),
                   let pk = try? PKDrawing(data: bin) {
                    self.savedDrawing = pk
                    self.drawingOffsetY = d.scrollY
                }
            }
        }

        self.blocks = newBlocks
        self.recomputeCanSave()
        // üîé ÎîîÎ≤ÑÍ∑∏: Ï≤´ Ïù¥ÎØ∏ÏßÄ URL ÌôïÏù∏
        if case let .image(f)? = self.blocks.first?.content {
            print("üñº tempFilename:", f.tempFilename ?? "nil")
        }
        print("‚úÖ blocks:", blocks.count, "drawing:", savedDrawing != nil)
    }

    // frameColor: ÏÑúÎ≤ÑÎäî "0","1",... Î¨∏ÏûêÏó¥ ‚Üí Ïï± enumÏúºÎ°ú Î≥ÄÌôò
    private func mapFrameColor(from raw: String) -> FrameColor {
//        if let i = Int(raw), let mapped = FrameColor(rawValue: i) {
//            return mapped
//        }
//        return .origin
        (Int(raw).flatMap { FrameColor(rawValue: $0) }) ?? .origin
    }
    
    private func makeRequestBody() -> DiaryRequestDTO {
        var items: [DiaryContentDTO] = []

        for block in blocks {
            switch block.content {
            case .text(let rich):
                let base64 = (rich.rtfData ?? Data()).base64EncodedString()
                items.append(.init(type: .text, rtfData: base64, imageData: nil, drawingData: nil))

            case .image(let f):
                // tempFilename ÌïÑÏàò! (Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÎÅùÎÇú ÌõÑ Ï†ÄÏû•Ìï¥Ïïº Ìï®)
                guard let temp = f.tempFilename, !temp.isEmpty else { continue }
                let img = DiaryImageDataDTO(
                    tempFilename: temp,
                    caption: f.caption,
                    frameColor: String(f.frameColor.rawValue),
                    date: f.date
                )
                items.append(.init(type: .image, rtfData: nil, imageData: img, drawingData: nil))
            }
        }

        if let d = savedDrawing {
            let base64 = d.dataRepresentation().base64EncodedString()
            let draw = DiaryDrawingDataDTO(base64: base64, scrollY: drawingOffsetY)
            items.append(.init(type: .drawing, rtfData: nil, imageData: nil, drawingData: draw))
        }

        return DiaryRequestDTO(contents: items)
    }

    func manualSave() {
        // Ìé∏Ïßë Ï§ëÏù∏ ÌÖçÏä§Ìä∏Î•º Î®ºÏ†Ä Ïª§Î∞ã
        if editingTextBlock != nil {
            saveCurrentEditingBlock()
            // ÏÑ†ÌÉù: Ïª§Î∞ãÍπåÏßÄ Í∞ôÏù¥
             commitEditingTextBlock()
        }
        guard canSave else {
            print("‚ö†Ô∏è Ï†ÄÏû• Î∂àÍ∞Ä: Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÎØ∏ÏôÑÎ£å ÎòêÎäî ÌÜ†ÌÅ∞/ÏÑúÎπÑÏä§ ÏóÜÏùå")
            return
        }
        guard let diaryService, let token else { return }

        let body = makeRequestBody()
        let isUpdate = hasDiary   // ‚Üê Ïù¥ Í∞íÏùÄ 2Îã®Í≥ÑÏóêÏÑú ÏÑ§Ï†ïÌï®

        let pub = isUpdate
            ? diaryService.updateDiary(logId: currentLogId, body: body, token: token)
            : diaryService.createDiary(logId: currentLogId, body: body, token: token)

        pub
            .receive(on: DispatchQueue.main)
            .sink { comp in
                if case let .failure(err) = comp { print("‚ùå manualSave error:", err) }
            } receiveValue: { [weak self] dto in
                Task { @MainActor in
                    self?.applyServerDiary(dto)  // ÏÑúÎ≤Ñ Ï†ïÍ∑úÌôî Î∞òÏòÅ
                    self?.hasDiary = true        // ÏµúÏ¥à ÏÉùÏÑ± ÌõÑÏóî Ìï≠ÏÉÅ PUT
                }
                print("‚úÖ Ï†ÄÏû• ÏôÑÎ£å")
            }
            .store(in: &bag)
    }

    // MARK: - ÏÇ¨ÏßÑ Ï≤òÎ¶¨
    func makeFramedDTOs(from items: [PhotosPickerItem]) async -> [FramedImageContent] {
        let indexed = Array(items.enumerated())
        var temp = Array<FramedImageContent?>(repeating: nil, count: indexed.count)

        await withTaskGroup(of: (Int, FramedImageContent?) .self) { group in
            for (idx, item) in indexed {
                group.addTask { [weak self] in
                    guard let self else { return (idx, nil) }
                    guard
                        let data = try? await item.loadTransferable(type: Data.self),
                        let uiImage = UIImage(data: data)
                    else {
                        return (idx, nil)
                    }

                    let dateString = await self.formattedPhotoDateString(from: item)
                    let dto = FramedImageContent(
                        image: Image(uiImage: uiImage),
                        caption: "",
                        frameColor: .origin,
                        date: dateString
                    )
                    dto.originalData = data
                    return (idx, dto)
                }
            }

            for await (idx, dto) in group {
                temp[idx] = dto
            }
        }

        return temp.compactMap { $0 } // Ïã§Ìå® Ìï≠Î™© Ï†úÍ±∞
    }
    
    // Ïù¥ÎØ∏ÏßÄ ÏàòÏ†ï
    func updateImageBlock(id: UUID, to newContent: FramedImageContent) {
        guard let idx = blocks.firstIndex(where: { $0.id == id }) else { return }

        // ÍµêÏ≤¥Îêú ÏΩòÌÖêÏ∏† Î∞òÏòÅ
        blocks[idx].content = .image(newContent)

        // ÏÉà ÌååÏùºÎ°ú Î∞îÍæº Í≤ΩÏö∞Ïóî ÏûÑÏãú URL Îã§Ïãú Î∞úÍ∏â ÌïÑÏöî
        let isReplacingFile = (newContent.originalData != nil)

        if isReplacingFile {
            // ÏóÖÎ°úÎìú Ï†ÑÏóêÎäî ÎπÑÏõåÎëêÍ≥† Ï†ÄÏû•Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî Ïú†ÎèÑ
            newContent.tempFilename = nil
            recomputeCanSave()

            if let data = newContent.originalData, let token, let imageService {
                imageService.uploadTemp(files: [data], token: token)
                    .map { $0.first?.fileUrl ?? "" }
                    .receive(on: DispatchQueue.main)
                    .sink { comp in
                        if case let .failure(err) = comp {
                            print("‚ùå uploadTemp (edit) error:", err)
                        }
                    } receiveValue: { [weak self] url in
                        newContent.tempFilename = url
                        self?.recomputeCanSave()
                        self?.forceUIUpdate.toggle()
                    }
                    .store(in: &bag)
            }
        } else {
            // Ï∫°ÏÖò/ÌîÑÎ†àÏûÑÎßå Î∞îÍæº Í≤ΩÏö∞
            recomputeCanSave()
        }

        // ÌïÑÏöî Ïãú Î¶¨Î†åÎçî
        forceUIUpdate.toggle()
    }
//    func updateImageBlock(id: UUID, to newContent: FramedImageContent) {
//        guard let idx = blocks.firstIndex(where: { $0.id == id }) else { return }
//        blocks[idx].content = .image(newContent)
//        // ÌïÑÏöî Ïãú Î¶¨Î†åÎçî Ìä∏Î¶¨Í±∞
//        forceUIUpdate.toggle()
//    }
    
    func extractPhotoDate(from item: PhotosPickerItem) async -> Date? {
        do {
            // 1. ÌååÏùº URL Í∞ÄÏ†∏Ïò§Í∏∞
            if let url = try await item.loadTransferable(type: URL.self) {
                let imageSource = CGImageSourceCreateWithURL(url as CFURL, nil)
                guard let imageSource else { return nil }

                // 2. Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                let metadata = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any]
                let exif = metadata?[kCGImagePropertyExifDictionary] as? [CFString: Any]

                // 3. ÎÇ†Ïßú ÌååÏã±
                if let dateTimeString = exif?[kCGImagePropertyExifDateTimeOriginal] as? String {
                    let formatter = DateFormatter()
                    formatter.dateFormat = "yyyy:MM:dd HH:mm:ss"
                    return formatter.date(from: dateTimeString)
                }
            }
        } catch {
            print("extractPhotoDate error: \(error)")
        }
        return nil
    }
    
    private let formatter: DateFormatter = {
        let df = DateFormatter()
        df.locale = Locale(identifier: "ko_KR") // ÌïúÍ∏Ä Í∏∞Ï§Ä Ï†ïÎ†¨
        df.dateFormat = "yyyy.M.d H:mm" // 2025.5.25 7:32
        return df
    }()
    
    func formattedPhotoDateString(from item: PhotosPickerItem) async -> String {
        if let date = await extractPhotoDate(from: item) {
            return formatter.string(from: date)
        } else {
            return formatter.string(from: Date())
        }
    }

    // MARK: - Block Management
    
    func addTextBlock() {
        let text = NSAttributedString(string: "")
        let content = RichTextContent(text: text)
        let block = DiaryBlock(content: .text(content))
        blocks.append(block)
        
        editingTextBlock = block
        richTextContext = content.context
        richTextContext.setAttributedString(to: text)
        richTextContext.fontSize = currentFontSize
        
        DispatchQueue.main.async {
            self.applyCurrentStyleToTypingAttributes()
        }
    }

    func saveCurrentEditingBlock() {
        guard let block = editingTextBlock,
              case .text(let content) = block.content else { return }

        let newText = richTextContext.attributedString
        if !content.text.isEqual(to: newText) {
            content.text = newText
            content.context = richTextContext
        }
    }

    func commitEditingTextBlock() {
        saveCurrentEditingBlock()
        editingTextBlock = nil
    }

    func addImages(_ images: [FramedImageContent]) {
        images.forEach { image in
            // ÌôîÎ©¥Ïóê Î®ºÏ†Ä Ï∂îÍ∞Ä
            let block = DiaryBlock(content: .image(image))
            blocks.append(block)
            
            // ÏóÖÎ°úÎìú
            if let data = image.originalData, let token, let imageService {
                imageService.uploadTemp(files: [data], token: token)
                    .map { $0.first?.fileUrl ?? "" }
                    .receive(on: DispatchQueue.main)
                    .sink { comp in
                        if case let .failure(err) = comp { print("‚ùå uploadTemp error:", err) }
                    } receiveValue: { [weak self] url in
                        image.tempFilename = url
                        self?.recomputeCanSave() // ÏóÖÎ°úÎìú ÌõÑ Ïû¨Í≥ÑÏÇ∞
                    }
                    .store(in: &bag)
            }
            else {
                recomputeCanSave() // Î∏îÎ°ùÎßå Ï∂îÍ∞ÄÌñàÏùÑ ÎïåÎèÑ
            }
        }
    }

    func startEditing(_ block: DiaryBlock) {
        guard case .text(let content) = block.content else { return }

        // 1) Ìé∏Ïßë Ïª®ÌÖçÏä§Ìä∏Ïóê ÌòÑÏû¨ ÌÖçÏä§Ìä∏Î•º Î®ºÏ†Ä Ï£ºÏûÖ
        content.context.setAttributedString(to: content.text)

        // 2) Î∑∞Î™®Îç∏ Ïª®ÌÖçÏä§Ìä∏ ÍµêÏ≤¥
        self.richTextContext = content.context

        // 3) ÎßàÏßÄÎßâÏóê Ìé∏Ïßë Î™®Îìú ÌîåÎûòÍ∑∏ (Î∑∞ Ïä§ÏúÑÏπò Ìä∏Î¶¨Í±∞)
        self.editingTextBlock = block

        // 4) (ÏÑ†ÌÉù) Ïä§ÌÉÄÏùº ÎèôÍ∏∞Ìôî/Ìè¨Ïª§Ïä§
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.syncStyleFromCurrentPosition()
            self.forceUIUpdate.toggle()
        }
    }

    func deleteBlock(_ block: DiaryBlock) {
        blocks.removeAll { $0.id == block.id }
        if editingTextBlock?.id == block.id {
            editingTextBlock = nil
        }
    }

    // MARK: - Style Management
    
    func setFontSize(_ size: CGFloat) {
        currentFontSize = size
        applyFontSizeChange()
    }
    
    func setFontFamily(_ fontName: String) {
        currentFontName = fontName
        applyFontFamilyChange()
    }
    
    func setUnderline(_ isUnderlined: Bool) {
        currentIsUnderlined = isUnderlined
        applyUnderlineChange()
    }
    
    func setStrikethrough(_ isStrikethrough: Bool) {
        currentIsStrikethrough = isStrikethrough
        applyStrikethroughChange()
    }
    
    func setTextAlignment(_ alignment: NSTextAlignment) {
        currentTextAlignment = alignment
        
        guard editingTextBlock != nil else { return }
        
        let mutableString = richTextContext.attributedString.mutableCopy() as! NSMutableAttributedString
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.alignment = alignment
        
        if mutableString.length == 0 {
            applyCurrentStyleToTypingAttributes()
            return
        }
        
        let fullRange = NSRange(location: 0, length: mutableString.length)
        mutableString.addAttribute(.paragraphStyle, value: paragraphStyle, range: fullRange)
        richTextContext.setAttributedString(to: mutableString)
        
        DispatchQueue.main.async {
            self.applyCurrentStyleToTypingAttributes()
            self.saveCurrentEditingBlock()
            self.forceUIUpdate.toggle()
        }
    }
    
    // MARK: - Private Methods
    
    private func applyFontSizeChange() {
        guard editingTextBlock != nil, let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            applyFontSizeToSelectedText(selectedRange)
        } else {
            applyCurrentStyleToTypingAttributes()
        }
        
        DispatchQueue.main.async {
            self.saveCurrentEditingBlock()
            self.forceUIUpdate.toggle()
        }
    }
    
    private func applyFontFamilyChange() {
        guard editingTextBlock != nil, let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            applyFontFamilyToSelectedText(selectedRange)
        } else {
            applyCurrentStyleToTypingAttributes()
        }
        
        DispatchQueue.main.async {
            self.saveCurrentEditingBlock()
            self.forceUIUpdate.toggle()
        }
    }
    
    private func applyUnderlineChange() {
        guard editingTextBlock != nil, let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            applyUnderlineToSelectedText(selectedRange)
        } else {
            applyCurrentStyleToTypingAttributes()
        }
        
        DispatchQueue.main.async {
            self.saveCurrentEditingBlock()
            self.forceUIUpdate.toggle()
        }
    }
    
    private func applyStrikethroughChange() {
        guard editingTextBlock != nil, let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            applyStrikethroughToSelectedText(selectedRange)
        } else {
            applyCurrentStyleToTypingAttributes()
        }
        
        DispatchQueue.main.async {
            self.saveCurrentEditingBlock()
            self.forceUIUpdate.toggle()
        }
    }
    
    private func applyFontSizeToSelectedText(_ range: NSRange) {
        let mutableString = richTextContext.attributedString.mutableCopy() as! NSMutableAttributedString
        
        mutableString.enumerateAttribute(.font, in: range, options: []) { fontAttribute, subRange, _ in
            if let existingFont = fontAttribute as? UIFont {
                if let newFont = UIFont(name: existingFont.fontName, size: currentFontSize) {
                    mutableString.addAttribute(.font, value: newFont, range: subRange)
                }
            } else {
                if let newFont = UIFont(name: currentFontName, size: currentFontSize) {
                    mutableString.addAttribute(.font, value: newFont, range: subRange)
                }
            }
        }
        
        richTextContext.setAttributedString(to: mutableString)
    }
    
    private func applyFontFamilyToSelectedText(_ range: NSRange) {
        let mutableString = richTextContext.attributedString.mutableCopy() as! NSMutableAttributedString
        
        mutableString.enumerateAttribute(.font, in: range, options: []) { fontAttribute, subRange, _ in
            let fontSize: CGFloat
            if let existingFont = fontAttribute as? UIFont {
                fontSize = existingFont.pointSize
            } else {
                fontSize = currentFontSize
            }
            
            if let newFont = UIFont(name: currentFontName, size: fontSize) {
                mutableString.addAttribute(.font, value: newFont, range: subRange)
            }
        }
        
        richTextContext.setAttributedString(to: mutableString)
    }
    
    private func applyUnderlineToSelectedText(_ range: NSRange) {
        let mutableString = richTextContext.attributedString.mutableCopy() as! NSMutableAttributedString
        
        if currentIsUnderlined {
            mutableString.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: range)
        } else {
            mutableString.removeAttribute(.underlineStyle, range: range)
        }
        
        richTextContext.setAttributedString(to: mutableString)
    }
    
    private func applyStrikethroughToSelectedText(_ range: NSRange) {
        let mutableString = richTextContext.attributedString.mutableCopy() as! NSMutableAttributedString
        
        if currentIsStrikethrough {
            mutableString.addAttribute(.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: range)
        } else {
            mutableString.removeAttribute(.strikethroughStyle, range: range)
        }
        
        richTextContext.setAttributedString(to: mutableString)
    }
    
    private func createCurrentStyleAttributes() -> [NSAttributedString.Key: Any] {
        var attributes: [NSAttributedString.Key: Any] = [:]
        
        // Ìè∞Ìä∏
        if let font = UIFont(name: currentFontName, size: currentFontSize) {
            attributes[.font] = font
        } else {
            attributes[.font] = UIFont.systemFont(ofSize: currentFontSize)
        }
        
        // Ï†ïÎ†¨
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.alignment = currentTextAlignment
        attributes[.paragraphStyle] = paragraphStyle
        
        // Î∞ëÏ§Ñ
        if currentIsUnderlined {
            attributes[.underlineStyle] = NSUnderlineStyle.single.rawValue
        }
        
        // Ï∑®ÏÜåÏÑ†
        if currentIsStrikethrough {
            attributes[.strikethroughStyle] = NSUnderlineStyle.single.rawValue
        }
        
        // Í∏∞Î≥∏ ÏÉâÏÉÅ
        attributes[.foregroundColor] = UIColor.label
        
        return attributes
    }
    
    private func applyCurrentStyleToTypingAttributes() {
        guard let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        if selectedRange.length > 0 { return }
        
        let attributes = createCurrentStyleAttributes()
        textView.typingAttributes = attributes
        
        // ÌïúÍ∏Ä IME ÎåÄÏùë
        for delay in [0.01, 0.02, 0.05] {
            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                if textView.selectedRange.length == 0 {
                    textView.typingAttributes = attributes
                }
            }
        }
        
        richTextContext.fontSize = currentFontSize
    }
    
    // ÌÖçÏä§Ìä∏ Î≥ÄÍ≤Ω ÌõÑ Ïª§ÏÑú ÏúÑÏπò Ïä§ÌÉÄÏùº ÎèôÍ∏∞Ìôî
    func handleTextChange(isDeleteOperation: Bool = false) {
        guard !isApplyingStyle else { return }
        
        if isDeleteOperation {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                self.syncStyleFromCurrentPosition()
            }
        }
    }
    
    // Ïª§ÏÑú Ïù¥Îèô Ïãú Ïä§ÌÉÄÏùº ÎèôÍ∏∞Ìôî
    func handleCursorPositionChange() {
        guard !isApplyingStyle else { return }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
            self.syncStyleFromCurrentPosition()
        }
    }
    
    private func syncStyleFromCurrentPosition() {
        guard let textView = findCurrentTextView() else { return }
        
        let selectedRange = textView.selectedRange
        if selectedRange.length > 0 { return }
        
        guard let attributedText = textView.attributedText else { return }
        let cursorPosition = selectedRange.location
        
        if attributedText.length > 0 && cursorPosition > 0 {
            let checkPosition = min(cursorPosition - 1, attributedText.length - 1)
            let attributes = attributedText.attributes(at: checkPosition, effectiveRange: nil)
            
            // Ìè∞Ìä∏ ÎèôÍ∏∞Ìôî
            if let font = attributes[.font] as? UIFont {
                currentFontSize = font.pointSize
                currentFontName = font.fontName
            }
            
            // Ï†ïÎ†¨ ÎèôÍ∏∞Ìôî
            if let paragraphStyle = attributes[.paragraphStyle] as? NSParagraphStyle {
                currentTextAlignment = paragraphStyle.alignment
            }
            
            // Î∞ëÏ§Ñ ÎèôÍ∏∞Ìôî
            if let underlineStyle = attributes[.underlineStyle] as? Int {
                currentIsUnderlined = underlineStyle != 0
            } else {
                currentIsUnderlined = false
            }
            
            // Ï∑®ÏÜåÏÑ† ÎèôÍ∏∞Ìôî
            if let strikethroughStyle = attributes[.strikethroughStyle] as? Int {
                currentIsStrikethrough = strikethroughStyle != 0
            } else {
                currentIsStrikethrough = false
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            DispatchQueue.main.async {
                self.forceUIUpdate.toggle()
            }
        }
        
        lastCursorPosition = cursorPosition
    }
    
    // MARK: - Getters
    
    func getCurrentFontSize() -> CGFloat { currentFontSize }
    func getCurrentFontName() -> String { currentFontName }
    func getCurrentIsUnderlined() -> Bool { currentIsUnderlined }
    func getCurrentIsStrikethrough() -> Bool { currentIsStrikethrough }
    
    func getCurrentTextAlignment() -> NSTextAlignment {
        let attributedString = richTextContext.attributedString
        guard attributedString.length > 0 else { return currentTextAlignment }
        
        if let paragraphStyle = attributedString.attribute(.paragraphStyle, at: 0, effectiveRange: nil) as? NSParagraphStyle {
            return paragraphStyle.alignment
        }
        
        return currentTextAlignment
    }
    
    // MARK: - Helper Methods
    
    private func findCurrentTextView() -> UITextView? {
        let scenes = UIApplication.shared.connectedScenes
        for scene in scenes {
            if let windowScene = scene as? UIWindowScene {
                for window in windowScene.windows {
                    if let textView = findTextViewInView(window) {
                        return textView
                    }
                }
            }
        }
        return nil
    }

    private func findTextViewInView(_ view: UIView) -> UITextView? {
        if let textView = view as? UITextView, textView.isFirstResponder {
            return textView
        }
        
        for subview in view.subviews {
            if let textView = findTextViewInView(subview) {
                return textView
            }
        }
        
        return nil
    }
    
    // MARK: - Drawing
    
    func loadSavedDrawing(diaryId: Int) {
        do {
            let result = try DrawingStore.load(diaryId: diaryId)
            self.savedDrawing = result.drawing
            self.drawingOffsetY = result.offsetY
        } catch {
            // ÌååÏùºÏù¥ ÏóÜÍ±∞ÎÇò Ïã§Ìå®ÌïòÎ©¥ Í∑∏ÎÉ• ÌëúÏãú Ïïà Ìï®
            self.savedDrawing = nil
            self.drawingOffsetY = 0
        }
    }
    
    func commitDrawingFromCanvas(_ drawing: PKDrawing, offsetY: CGFloat, autosave: Bool = false) {
        self.savedDrawing = drawing
        self.drawingOffsetY = offsetY
        if autosave, canSave { // Ïù¥ÎØ∏ÏßÄ ÏûÑÏãúURL Îì± Ï°∞Í±¥ Ï∂©Ï°± ÏãúÏóêÎßå Ï¶âÏãú Ï†ÄÏû•
            manualSave()
        }
    }
}
